---
title: "R Notebook"
output: html_notebook
---
Select 100 genes from the real data for estimating parameters, required for generating simulations.

```{r}
normalized_clust1_full <- read.delim("~/Documents/Documents/Summer_2019/Mouse_Liver/Rance/SampleData/normalized_clust1_full.txt", header=TRUE)
gene_metadata_clust1_full <- read.csv("~/Documents/Documents/Summer_2019/Mouse_Liver/Rance/SampleData/gene_metadata_clust1_full.txt", row.names=1, sep="")
cell_metadata_clust1 <- read.delim("~/Documents/Documents/Summer_2019/Mouse_Liver/Rance/SampleData/cell_metadata_clust1.txt", row.names=1)
```


```{r}
#Store the dose information
dose_level<-factor(cell_metadata_clust1$Dose)
#Create new data frame with rows as cells and columns as genes and dose information
normalized_clust1_full_dose<-data.frame(t(normalized_clust1_full),
                    cell_metadata_clust1[,"Dose"])
colnames(normalized_clust1_full_dose)[ncol(normalized_clust1_full_dose)]<-"Dose"
```

Create a data list of length = levels of dose. Each element of the list is a dataframe of cells as columns and rows as genes

```{r}
data<-rep(list(data.frame()), nlevels(dose_level))
names(data)<-levels(dose_level)
for(i in levels(dose_level))
{
data[[i]]<- subset(normalized_clust1_full_dose
                   , Dose == i, select = Hao1:Slc6a1)
##data[[i]] is a list of all the seperate dose gene*cell matrices
data[[i]][] <- lapply(data[[i]], function(x) as.numeric(as.character(x)))
data[[i]]<-t(data[[i]])
}
```

Filtering

```{r}
# Identify the genes expressed in less than 5% of the cells over all the dose groups
propor<-sapply(data,function(x) apply(x,1,function(x) length(which(x!=0))/length(x)))
b<-which(apply(propor,1,function(x) all(x>0.05))== TRUE)
#Filter out genes
data_filt<-lapply(data,function(x) apply(x,2,function(x) x[b]))
gene_metadata_clust1_full_filt<-as.data.frame(gene_metadata_clust1_full[b,])
rownames(gene_metadata_clust1_full_filt)<-names(b)
normalized_clust1_full_dose_filtered<-normalized_clust1_full_dose[,c(b,ncol(normalized_clust1_full_dose))]
```

Find the coefficient of variation for all the genes
```{r}
#Find coefficient of variation for each gene
cv_normalized_clust1_full_dose_filtered<-apply(normalized_clust1_full_dose_filtered[,1:6826],2,
          function(x) sd(x, na.rm=TRUE)/mean(x, na.rm=TRUE)*100)
```


```{r}
#Order the genes by their CV
ord<-order(cv_normalized_clust1_full_dose_filtered)
#Since the genes with the top CV have almost no dropouts we take the middle HVG genes which have standard dropout rates ranging from 0.1-0.3
ord[500:720]
#Select among these high CV genes, the ones that have absolute logFC greater than 1,5
reg<-which(gene_metadata_clust1_full_filt[ord[500:720],]>1.5)
#Select the indexes of the genes that are regulated
ord[500:720][reg]
#Select indices of unregulated genes
ord[500:720][-reg]
#Select 20 regulated genes
reg_gene<-rownames(gene_metadata_clust1_full_filt)[ord[500:720][reg][1:20]]
#Select 80 unregulated genes
unreg_gene<-rownames(gene_metadata_clust1_full_filt)[ord[500:720][-reg][1:80]]
```

Create data list for the selected genes, first 20 are regulated
Regulated here means gene has an absolute log fold change greater than 1.5

```{r}
gene_metadata_small<-gene_metadata_clust1_full_filt[c(reg_gene,unreg_gene),1]
normalized_data_dose_small<-normalized_clust1_full_dose_filtered[,c(reg_gene,unreg_gene,"Dose")]
#Look at the group-wise summary of these 100 genes
dsg<-data_group_summary(normalized_data_dose_small)
data_small<-lapply(data, function(x) x[c(reg_gene,unreg_gene),])
```

We fit a separate hurdle normal distribution for the k-groups of each gene.

```{r}
data_group<-lapply(data_small,function(x) as.data.table(t(x)))
data_group<-lapply(data_group,function(x) setDT(x))

for(i in rownames(data_small[["0"]]))
{
 lapply(data_group, function(x) x[,noquote(paste("d", i, sep = "_")) := ifelse(x[[noquote(i)]] == 0, 0, 1)])
}
#Fit a logistic distribution for the dropout indicator
logistic.fit<-rep(list(rep(list(list()),nrow(data_small[["0"]]))),nlevels(dose_level))
#Fit a linear model to the positively expressed values
ols.fit<-rep(list(rep(list(list()),nrow(data_small[["0"]]))),nlevels(dose_level))

#Parameters
#prob_success_group is the 1-dropout probability of each group
prob_success_group<-rep(list(vector("numeric",length = nrow(data_small[["0"]]) )),nlevels(dose_level))
#mean_exp_group is the mean gene expression for each group
mean_exp_group<-rep(list(list()),nlevels(dose_level))
#sd_exp_group is the sd of the gene expression for each group
sd_exp_group<-rep(list(list()),nlevels(dose_level))
for(k in levels(dose_level))
{
  for(i in rownames(data_small[["0"]]))
  {
   logistic.fit[[k]][[i]]<-  glm(formula = data_group[[k]][[noquote(paste("d", i, sep = "_"))]] ~ 1 , data= data_group[[k]], family = binomial)
   prob_success_group[[k]][i]<-exp(logistic.fit[[k]][[i]]$coefficients)/
    (exp(logistic.fit[[k]][[i]]$coefficients)+1)
   ols.fit[[k]][[i]] <- lm(formula = data_group[[k]][[noquote(i)]][data_group[[k]][[noquote(i)]]>0]~1)         
  }
 mean_exp_group[[k]]<-sapply(ols.fit[[k]], function(x) x$coefficients) 
 sd_exp_group[[k]]<-sapply(ols.fit[[k]], function(x) summary(x)$sigma)
}
```



Generate 100 simulations of each of the 100 genes, each having 1000 cells, from all K groups.

```{r}
n <- 1000
set.seed(100)
iter=100
K=nlevels(dose_level)
#Observed data for K = 9 groups
y.norm<-rep(list(rep(list(matrix(data=NA,nrow=iter,ncol=n)),times=K)),100)
names(y.norm)<-rownames(data_small[["0"]])
for(j in 1: length(y.norm))
{
  names(y.norm[[j]])<-levels(dose_level)
}
for(j in 1: nrow(data_small[["0"]]))
{
  for(k in levels(dose_level))
{
  for(i in 1:iter)
  {
  set.seed(100*i)
  y.norm[[j]][[k]][i,]<-rbinom(n, 1, prob_success_group[[k]][j]) * 
              rnorm(n,mean_exp_group[[k]][j],sd_exp_group[[k]][j])
  }
}
}
#y.norm is the simulated data
```

```{r}
#Set the parameters of the model
library(matrixStats)
#Choose the scaling constant tau_mu
tau_t_mu = tau_c_mu = tau_mu = c(0.5,1,2,3)
tau_k_mu<-rep(1,9)
#Use sigma_mean and sigma_var to solve for b_sigma and a_sigma
b_sigma = 3
a_sigma = 7
#Use mean and variance of omega to solve for a_w and b_w
#We keep the same values of a_w and b_w for all groups since the omega mean and omega SD values are more or less consistent.
a_w_group<-c(8,10,11,11,10,10,10,8,3)
b_w_group = c(2,2,2,2,4.9,9,9,3,2)
a_w<-mean(a_w_group)
b_w<-mean(b_w_group)
#length(which(simulated.gene.metadata$Category == "Positive"))
prior_Alter<-c(1-((0.20)^(1/20)),0.01,0.05,0.1, 0.2,0.3,0.4,0.5)
prior_Null<- 1-prior_Alter
```


```{r}
#actual bayes factor multiple computed in overleaf
##BF FDR control using jeffreys 
bf_multiple_01<-rep(list(rep(list(list()),100)), nrow(data_small[["0"]]))
source('~/Documents/Documents/Summer_2019/Mouse_Liver/Rance/snSeq-DGE/R/BayesFactorMultiple.R')
for(j in 1:nrow(data_small[["0"]]))
{
  for(i in 1: iter)
  {
   bf_multiple_01[[j]][[i]]<-Bayes_factor_multiple(
                          Y = list(Y_1=as.matrix(y.norm[[j]][["0"]][i,]), 
                           Y_2=as.matrix(y.norm[[j]][["0.01"]][i,]),
                           Y_3=as.matrix(y.norm[[j]][["0.03"]][i,]),
                           Y_4=as.matrix(y.norm[[j]][["0.1"]][i,]),
                           Y_5=as.matrix(y.norm[[j]][["0.3"]][i,]),
                           Y_6=as.matrix(y.norm[[j]][["1"]][i,]),
                           Y_7=as.matrix(y.norm[[j]][["3"]][i,]),
                           Y_8=as.matrix(y.norm[[j]][["10"]][i,]),
                           Y_9=as.matrix(y.norm[[j]][["30"]][i,])),
                           m_0=mean(c(mean_exp_group[["0"]][j],
                              mean_exp_group[["0.01"]][j],
                              mean_exp_group[["0.03"]][j],
                              mean_exp_group[["0.1"]][j],
                              mean_exp_group[["0.3"]][j],
                              mean_exp_group[["1"]][j],
                              mean_exp_group[["3"]][j],
                              mean_exp_group[["10"]][j],
                              mean_exp_group[["30"]][j])),
                           m=c(mean_exp_group[["0"]][j],
                              mean_exp_group[["0.01"]][j],
                              mean_exp_group[["0.03"]][j],
                              mean_exp_group[["0.1"]][j],
                              mean_exp_group[["0.3"]][j],
                              mean_exp_group[["1"]][j],
                              mean_exp_group[["3"]][j],
                              mean_exp_group[["10"]][j],
                              mean_exp_group[["30"]][j]), K=9,
                           tau_k_mu =tau_k_mu,tau_mu=tau_mu[2], 
                           b_sigma=3,a_sigma=7,a_w,b_w,
                           prior_alt =prior_Alter[5],
                           prior_null = prior_Null[5]) 
  }
}

```


```{r}
#Extract the Bayes factors for 100 iterations of all the 100 genes
bf_multiple_01_value<-lapply(bf_multiple_01,function(x) sapply(x, function(x) exp(x$l_Bayes_factor_01)))
# BF decision
bf_multiple_01_decision<-lapply(bf_multiple_01_value,function(x)
  ifelse(x < (1/3), "Positive","Negative"))

```

```{r}
#Benchmark performance with the ANOVA and KW test.
mydata<-rep(list(data.frame()),length(y.norm))
my_data_kruskal_p_value<-rep(list(vector()),length(y.norm))
my_data_anova_p_value<-rep(list(vector()),length(y.norm))
for(j in 1:length(y.norm))
{
  mydata[[j]]<-data.frame(t(data.frame(y.norm[[j]][[1]],y.norm[[j]][[2]],
                   y.norm[[j]][[3]],y.norm[[j]][[4]],y.norm[[j]][[5]],
                   y.norm[[j]][[6]],y.norm[[j]][[7]],y.norm[[j]][[8]],
                                               y.norm[[j]][[9]])),
                     c(rep(0,1000),rep(0.01,1000),rep(0.03,1000),
                       rep(0.1,1000),rep(0.3,1000),rep(1,1000),
                       rep(3,1000),rep(10,1000),rep(30,1000))) 
  colnames(mydata[[j]])<-c(rownames(data_small[["0"]]),"Dose")
  my_data_kruskal_p_value[[j]]<-KW_test(mydata[[j]])
  my_data_anova_p_value[[j]]<-anova_test(mydata[[j]])
}
my_data_anova_pred_dec<-lapply(my_data_anova_p_value,function(x)
  ifelse(x < 0.05, "Positive","Negative"))
my_data_kruskal_pred_dec<-lapply(my_data_kruskal_p_value,function(x)
  ifelse(x < 0.05, "Positive","Negative"))
```

